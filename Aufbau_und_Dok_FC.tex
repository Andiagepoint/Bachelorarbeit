\section{Geforderte Funktionseigenschaften}
Die zu schreibende MATLAB Funktion soll nach Fertigstellung in weiteren MATLAB Programmen zum Einsatz kommen. Daher ist es wichtig, dass sämtliche Daten die für das Ausführen erforderlich sind bereits im Code vorliegen und nicht importiert werden müssen. Es sollen auch sonst nach dem Ausführen keine weiteren Maßnahmen oder Eingaben getätigt werden müssen. Um diesen Voraussetzungen gerecht zu werden, ist es erforderlich vor allem große Datensätze im Code einzubinden.\label{createstruct} Bei dieser Arbeit ist das zum einen die Städteliste mit ihren über 1000 Einträgen und zum anderen das Verzeichnis mit allen Registeradressen, in Summe über 340 Positionen. Daneben gibt es noch ein paar weitere Eigenschaften, die an dieser Stelle kurz aufgeführt werden.
\begin{itemize}
\item wiederholte Ausführung des Datenabrufs in bestimmten Zeitabschnitten ohne dabei MATLAB komplett zu blockieren
\item Handhabung der kompletten MODBUS Kommunikation, insbesondere des Datenabrufs, der -verarbeitung und der Parametersetzung
\item Interpolation der ausgelesenen Werte, um unterschiedliche zeitliche Auflösungen zu erhalten
\item Datensicherung derart, dass jeder Datenabruf in einer eigenen Datei und die Summe aller abgerufenen Werte in einer anderen Datei gespeichert werden
\item Fehlervermeidung bei der Eingabe von Inputparametern
\item Aufbau und Beendigung der seriellen Schnittstelle mit der Wetterstation
\item einfache und kurze Inputparameter
\end{itemize}
Nachdem die Eigenschaften nun bekannt sind, soll in den nachfolgenden Unterkapiteln die genaue Umsetzung im Programmcode erläutert werden. Hierzu wird zunächst eine grobe Struktur des Programmaufbaus in \textbf{Abbildung \ref{fig:flowchart}} gegeben. 
\begin{figure}
\centering
\includegraphics[scale=1]{programm/flowchart}
\caption{Ablaufplan der Funktion forecast\_data}
\label{fig:flowchart}
\end{figure} 
Wie in der \textbf{Abbildung \ref{fig:funkaufruf}} zu erkennen, ist es möglich für die Funktion \textsf{forecast\_data} acht Eingabeparameter zu definieren. 
\begin{enumerate}
\item Wetterregion, z.B. \textbf{'München'}
\item Prognosebereichsdefinition z.B. \textbf{'niederschlag-menge-all'}
\item Start des Beobachtungszeitraums, z.B. \textbf{'23-Jan-2014'}
\item Ende des Beobachtungszeitraums, z.B. \textbf{'23-Jan-2014'}
\item zeitliche Auflösung, z.B. \textbf{1}
\item Updateintervall, z.B. \textbf{6}
\item zeitlicher Offset nach dem Ausführen der Funktion, z.B. \textbf{3}
\item Pfadangabe des Speicherortes (optional), z.B. \textbf{'C:\textbackslash Test'}
\end{enumerate}
\begin{figure}
\centering
\includegraphics[scale=0.7]{programm/funkaufruf}
\caption{Beispiel für den Funktionsaufruf}
\label{fig:funkaufruf}
\end{figure}
Die Wetterregion wird als Stadtname in Stringformat übergeben. Die Prognosebereichsdefinition besteht aus drei Teilen, die als String in diesem Format 'Prognosebereich-Prognosedetail-Prognoseintervall' aufgebaut ist. Der erste Teil gibt den Wetterbereich an. Hier stehen alle Einträge in der Spalte Prognosebereich der \textbf{Tabelle \ref{tab:detaildatenstruktur}} im Anhang zur Verfügung. Die Prognosedetaildaten können der zweiten Spalte dieser Tabelle entnommen werden. Der dritte Parameter gibt die Anzahl der auszuwertenden Tage an, dabei steht der Wert 1 für den aktuellen Tag ohne Prognose und die Werte 2, 3, 4 für eine entsprechende Erweiterung des aktuellen Tages um die Prognosetage 1, 2 und 3 sofern vorhanden. Um mehrere selektive Prognosebereiche abzurufen, gibt es die Möglichkeit diese als Cell-Array zu definieren. Dabei wird das Cell-Array als Zeilenvektor in dieser Form \textit{\{Prognosebereichsdefinition\_1;Prognosebereichsdefiniton\_2\}} definiert. Möchte man keine gesonderte Auswahl treffen und einfach alle möglichen Wetterdaten abrufen, so kann hier an dieser Stelle der Input 'all' erfolgen. Der Beobachtungszeitraum wird durch zwei Daten begrenzt, die ebenfalls als String in dieser Formation 'dd-mmm-yyyy', wobei mit mmm der englische Monatsname gemeint ist, angegeben werden. Die zeitliche Auflösung wird als Double eingetragen. Hier sind die Werte 6, 1, 0.5, 0.25, 0.08 stellvertretend stehend für eine Interpolation mit einer Auflösung von einer Stunde, einer halben Stunde, einer viertel Stunde und 5 Min., möglich. Wählt man den Wert 6 so erfolgt keine Interpolation der Daten. Das Updateintervall wird ebenfalls als Double definiert. Hier stehen die Werte 6, 12 und 24 zur Verfügung, welches einem vier-, zwei- und einmaligen Update am Tag entspricht. Wann das einmalige Update am Tag genau erfolgen soll, kann man mit dem vorhin erwähnten Offset festgelegt werden. Umfasst der Beobachtungszeitraum den aktuellen Tag der Funktionsausführung, so verschiebt sich der Datenabruf nach Funktionsauführung um den Offsetwert nach hinten. Liegt der Startpunkt des Beobachtungszeitraums in der Zukunft, erfolgt die Offsetverschiebung ab 0.00 Uhr des Beobachtungsbeginns. Die Pfadangabe wird wiederum als String eingegeben. Die \textbf{Abbildung \ref{fig:funkaufruf}} gibt hierzu ein Beispiel. Es wird für die Region München die Niederschlagsmenge für den heutigen Tag, die Windstärke für den heutigen und den nachfolgenden Tag, über einen Zeitraum von zwei Tagen abgerufen. Dabei beträgt die zeitliche Auflösung eine Stunde und das Intervall in denen Updates gestartet werden 6 Stunden. Der Datenabruf erfolgt eine halbe Stunde nach Funktionsausführung. Nachdem hier kein Speicherpfad angegeben ist, wird ein Ordner mit der Bezeichnung \enquote{Aufzeichnungen} im aktuellen MATLAB Ordner erstellt und als Speicherort ausgewählt. 
\section{Vorbereitende Maßnahmen}
\subsection{Zuweisung variabler Inputparameter und Variableninitiierung}
Als erstes wird der Default-Ordner \textit{filepath} für das Abspeichern der Daten festgelegt. Dabei wird nachgesehen, ob lediglich eine Laufwerksangabe für den aktuellen MATLAB Ordner vorliegt oder nicht. Für den Fall, dass variable Inputparameter übergeben wurden, wird zuerst geprüft, ob die Anzahl der geforderten Werte vorhanden ist. Ist das nicht der Fall, so wird eine Meldung an den Nutzer ausgeben und die Funktion beendet. Stimmt die Anzahl, werden die Werte Funktionsvariablen zugeordent. Möchte man den Zeitpunkt, zu dem der erste Datenabruf nach Ausführen der Funktion erfolgt, verschieben, so kann man einen zeitlichen Offset (Angabe als String in Stunden) als siebtes Inputargument übergeben. Wenn Startzeitpunkt des Beobachtungsintervalls und Funktionsausführung am gleichen Tag liegen, so bewirkt der Offset eine Verschiebung vom Ausführungszeitpunkt der Funktion an. Liegt das Startdatum jedoch in der Zukunft, so findet die Verschiebung von 0.00 Uhr des Startdatums an, statt. Ist zudem noch eine Pfadangabe zu einem Speicherort der Funktion übergeben worden, so wird diese ebenfalls einer Funktionsvariablen zugewiesen. Wurden keine Angaben zu den beiden Werten gemacht, so wird im aktuellen MATLAB Ordner der Default-Ordner \enquote{Aufzeichnungen} als Speicherplatz definiert und der Offset auf Null gesetzt. Existiert der Ordner bereits, erfolgt eine Meldung auf deutsch. Wurden keine variablen Parameter übergeben (entspricht einem einmaligen sofortigen Abruf), so wird die zeitliche Auflösung auf 1 Stunde und der Offset auf Null festgesetzt und ebenfalls der Default-Speicherort vorgegeben. 
\lstinputlisting[firstline=69, lastline=113]{programm/forecastdata.m}
Nachdem die \textit{forecast\_definition} sowohl als String als auch als Cell-Array übergeben werden kann, im späteren Programmablauf aber nur ein Cell-Array erwartet wird, muss im Fall eines Strings eine Konvertierung zum Cell-Array stattfinden.\label{sendloop} Mit dem ersten Funktionsaufruf, an dem noch kein Tageswechsel auftreten kann, werden die Variablen \textit{daychange\_flag} und \textit{daychange\_counter} auf Null gesetzt und dem Base-Workspace zugewiesen. Ebenso initialisiert werden die späteren Datencontainer \textit{weather\_data} und \textit{new\_data}. Wie in \textbf{Tabelle \ref{tab:parabel}} auf Seite~\pageref{tab:parabel} gezeigt, lautet die Slave-ID der Wetterstation \enquote{03}. Diese wird hier der \textit{device\_id} zugeordnet. 
\lstinputlisting[firstline=115, lastline=132]{programm/forecastdata.m}   
\subsection{Aufbau von Strukturen} 
Wie bereits im vorigen Kapitel~\ref{createstruct} angekündigt, müssen große Datensätze in Strukturen gepackt werden um später aus ihnen Daten zu gewinnen. Sollen alle Wetterdaten abgerufen werden, ist es erforderlich ein Cell-Array \textit{fc\_def} aufzubauen, welches alle Wetterdatenanfragen beinhaltet. Danach werden Strukturen angelegt, die die Registeradressen und Städtenamen abbilden. Die letzten beiden Strukturen müssen wieder im Base-Workspace verfügbar sein da andere Funktionen auf sie zurückgreifen werden.
\lstinputlisting[firstline=136, lastline=149]{programm/forecastdata.m}
\subsection{Überprüfung der Eingabeparameter}
Diese for-Schleife bearbeitet alle übergebenen Wetterdatenanfragen, prüft sie mit der Funktion \textsf{input\_check} auf Gültigkeit und erstellt zugleich die entsprechenden Datencontainer. Die Datencontainer werden im Base-Workspace eingetragen. Sind ein oder mehrere Eingabeparameter falsch, werden diese dem Nutzer mit einer Nachricht angezeigt und die Funktion beendet.
\lstinputlisting[firstline=153, lastline=174]{programm/forecastdata.m}
Die Funktion \textsf{input\_check}, die nachfolgend erläutert wird, liefert als Outputparameter einen Vektor \textit{val\_inpt} der angibt, welche Parameter gültig sind. Zusätzlich werden die generierten Fehlermeldungen \textit{err\_msg}, die ID der Wetterregion \textit{c\_id} und der Breiten- und Längengrad ausgegeben. Im ersten Abschnitt des Input Checks wird die Funktion \textsf{get\_city\_id} aufgerufen, um die ID der Wetterregion, den Längen- und Breitengrad zu ermitteln. Längen- und Breitengrade wurden aus Google Earth übernommen \cite{googleearth}. Ist die ID nicht in der Liste zu finden, wird die entsprechende Vektorposition \textit{val\_inpt} auf Null gesetzt .
\lstinputlisting[firstline=1, lastline=16]{programm/inputcheck.m}
Betrachtet man die unten aufgeführte Funktion \textsf{get\_city\_id}, so muss zuerst die im Base-Workspace befindliche Variable \textit{city\_list} zugänglich gemacht werden. Danach wird die Spalte mit den Städtenamen mit \textsf{nominal} konvertiert, um im darauffolgenden Schritt eine einfache Suche der Position in der Liste, die dem Städtenamen entspricht, zu starten. In der Variable \textit{city\_data\_set} sind nun alle Werte dieser Listenzeile, enthalten. Eine einfache Wenn-Dann-Bedingung weist die Daten den Outputparametern zu.   
\lstinputlisting[firstline=1, lastline=18]{programm/getcityid.m}
An dieser Stelle des Input-Checks wird die Wetterdatenanfrage analysiert. Kommt in dem Ausdruck nicht zweimal ein Querstrich vor, ist die Eingabe schon fehlerhaft. Wenn doch, werden die drei einzelnen Bestandteile mit Listen abgeglichen und bei entsprechender Existenz keine Fehlermeldung ausgegeben.  
\lstinputlisting[firstline=19, lastline=62]{programm/inputcheck.m}
Die Überprüfung des Observationszeitraums erfolgt dahingehen, dass der Ausdruck ein Datumsformat darstellen muss, den MATLAB mittels \textsf{datenum} konvertieren kann. Ist dies nicht möglich, liegt ein Fehler vor. Sind die Datumsformate korrekt, so kann es immer noch der Fall sein, dass das Startdatum in der Vergangenheit oder nach dem Enddatum liegt. Auch hier werden entsprechende Fehlermeldungen generiert.  
\lstinputlisting[firstline=65, lastline=103]{programm/inputcheck.m}
Im letzten Teil der Überprüfung werden die Werte der zeitlichen Auflösung und des Updateintervalls wieder mit Listen abgeglichen. Ist der Gültigkeitsvektor in der boolschen Überprüfung wahr, werden keine Fehlermeldungen ausgegeben. 
\lstinputlisting[firstline=105, lastline=129]{programm/inputcheck.m}
\subsection{Verfügbarkeitsprüfung der seriellen Schnittstelle}   
Existiert bereits eine Variable \textit{serial\_interface} im Base-Workspace, so wird diese gelöscht. Danach wird die Verfügbarkeit des COM6 Ports festgestellt. Ist der COM6 Port bereits in Benutzung, so wird dem Nutzer die Möglichkeit gegeben, diese Nutzung zu beenden oder nicht. Dies ist zum Beispiel der Fall, wenn eine serielle Schnittstelle auf dem COM6 Port existiert hat und nicht ordnungsgemäß gelöscht wurde. 
\lstinputlisting[firstline=178, lastline=211]{programm/forecastdata.m} 
\section{Aufbau der seriellen Schnittstelle}
Die Funktion \textsf{open\_serial\_port} enthält bereits alle in der \textbf{Tabelle \ref{tab:parabel}} auf Seite~\pageref{coilabfrage} festgelegten Schnittstellenparameter.
\lstinputlisting[firstline=213, lastline=214]{programm/forecastdata.m}
MATLAB bietet für den Aufbau einer seriellen Schnittstelle eine Funktion namens \textsf{serial} an. Diese wird hier zur Erstellung der Variable \textit{serial\_interface} angewandt. Die Variable wird dem Base-Workspace zugewiesen und die serielle Schnittstelle mit dem Befehl \textsf{fopen} geöffnet. Der Nutzer wird über den Schnittstellenaufbau informiert.
\lstinputlisting[firstline=1, lastline=17]{programm/openserialport.m}
\section{Abgleich der Wetterregion im Register}
Da der Wechsel einer Wetterregion unter Umständen mehrere Stunden bis zu drei Tagen dauern kann, bis alle anliegenden Werte Gültigkeit besitzen, wird in diesem Teil des Codes zuerst die bereits eingetragene ID der Wetterregion mit der Funktion \textsf{read\_com\_set} ausgelesen und mit der in dem Funktionsaufruf Angegebenen verglichen. Die Funktionsweise von \textsf{read\_com\_set} kann im Anhang unter~\ref{sec:readcomset} auf S.~\pageref{sec:readcomset} nachvollzogen werden. Weichen die beiden Werte voneinander ab, so wird der Nutzer per Tastatureingabe aufgefordert dem Wetterregionenwechsel zuzustimmen. Er hat somit die Gelegenheit einen versehentlichen Wechsel abzubrechen. Anschließend wird der neue Wert im Register eingetragen. Hierzu wird die Funktion \textsf{write\_com\_set} verwendet (siehe Anhang ~\ref{sec:writecomset} auf S.~\pageref{sec:writecomset}). 
\lstinputlisting[firstline=216, lastline=243]{programm/forecastdata.m}
\section{Festlegung der Timerparameter und Starten des Timers}
Um die Eigenschaft des wiederholten Datenabrufs zu implementieren wurde das Timer-Objekt von MATLAB verwendet. Es bietet den Vorteil im Hintergrund zu laufen ohne dabei MATLAB komplett zu blockieren. Um dieses Objekt sinnvoll einsetzen zu können, müssen zuerst ein paar Parameter ermittelt werden. Insbesondere betrifft dies das Timerintervall, die Anzahl der Timerausführungen und die Timerverzögerung. Das Timerintervall \textit{update\_interval\_hours} lässt sich einfach dadurch berechnen, indem die Variable \textit{update\_interval} mit der Anzahl an Sekunden für eine Stunde multipliziert wird. Die Anzahl der Timerausführungen ergibt sich durch die zur Verfügung stehenden Stunden im Beobachtungszeitraum dividiert durch die Länge des Timerintervalls. Liegt der Beobachtungszeitraum in der Zukunft, so muss die Timerverzögerung genau die Länge vom Funktionsaufruf bis zum Startdatum plus einem evtl. Offset aufweisen. Bei der Berechnung dieser Angaben sind die MATLAB Funktionen \textsf{days365}, \textsf{datevec} sowie \textsf{etime} äußerst nützlich.
\lstinputlisting[firstline=245, lastline=285]{programm/forecastdata.m}
Mit der Zuweisung \enquote{t = timer} wird in der Variablen \textit{t} das Timer-Objekt erzeugt. Die Eigenschaften können dann ähnlich einer Struktur in MATLAB aufgerufen und bestimmt werden. Zu bestimmen sind die Timerverzögerung (\textit{t.StartDelay}), das Timerintervall (\textit{t.Period}), die Timerausführungen (\textit{t.TasksToExecute}), sowie die Ausführungsmethode (\textit{t.ExecutionMode}). Die Ausführungsmethode \enquote{fixedRate} garantiert, dass in genau gleichen Timerintervallen die in der Timerfunktion (\textit{t.TimerFcn}) definierte Funktion ausgeführt wird. Wird der Timer durch einen Fehler oder durch einen Abbruchbefehl unterbrochen, so legt man in der Timerstopfunktion \textit{t.StopFcn} fest, was geschehen soll. 
\lstinputlisting[firstline=287, lastline=319]{programm/forecastdata.m}    
Kommt es zu einem Timerabbruch, wird die Funktion \textsf{stop\_timer}, hier nachfolgend zu sehen, ausgeführt.  Dabei wird eine Meldung an den Nutzer ausgegeben, das Timer-Objekt gelöscht und der Datencontainer \textit{weather\_data} mit den fortlaufenden Werten abgespeichert. Außerdem wird die serielle Schnittstelle beendet. Der Dateiname für den Datencontainer setzt sich zusammen aus der Wetterregion, der angewandten zeitlichen Auflösung, dem aktuellen Datum und dem aktuellen Datum in Unix Zeitformat. Der Abbruch erfolgt dabei entweder durch einen Fehler bei der Programmausführung oder durch bewusstes Löschen des Timerobjektes. Dieses Löschen kann durch die Funktion \textsf{stop\_forecast\_data}, die nur den Befehl \textsf{delete(timerfindall)} beinhaltet, herbeigeführt werden.
\lstinputlisting{programm/stoptimer.m}    
\section{Abschicken der MODBUS-Anfragen}
\begin{table}[htbp]
\caption{Inputparameter für die Funktion send\_loop}
\setlength{\extrarowheight}{0.1cm}
\begin{tabular}{| p{2cm} | p{3cm} | p{2.5cm} | p{2cm} | p{2cm} | p{2cm} |}
\hline
\rowcolor{cyan}
\textit{obj} & \textit{event} & \textit{t} & \textit{fc\_def} & \textit{dev\_id} &  \textit{f\_path}\\[0.25cm]
\hline
\rowcolor{white}
Timer-Objekt & Timer-Event & Anzahl der Wetterbereichsdefinitionen & \parbox[t]{2cm}{Wetter-\\bereichs-\\definitionen} & Id des MODBUS Slave & Pfad zum Speicherort \\
\hline
\rowcolor{cyan}
\textit{c\_id} & \textit{u\_c\_n} & \textit{res} & \textit{lng} & \textit{lat} & \\[0.25cm]
\hline
\rowcolor{white}
ID der Wetterregion & Anzahl der noch verbleibenden Abrufvorgänge & gewünschte zeitliche Auflösung & Längengrad & Breitengrad & \\
\hline
\end{tabular}
\label{tab:parasendloop}
\end{table} 
Die Funktion \textsf{send\_loop}, die das sequentielle Abschicken und Verarbeiten der einzelnen MODBUS Nachrichten übernimmt wird hier erläutert. Die Definition der Eingabeparameter kann der \textbf{Tabelle \ref{tab:parasendloop}} entnommen werden. Nachdem die Eingabeparameter übergeben wurden, werden die im Base-Workspace vorhandenen Variablen \textit{daychange\_flag}, \textit{daychange\_counter}  sowie der Datencontainer \textit{w\_dat} für die fortlaufenden Wetterdaten in dieser Funktion bereitgestellt. Eine for-Schleife durchläuft dann alle Wetterdatenanfragen die in \textit{fc\_def} definiert wurden. Beim ersten Durchlauf muss geprüft werden, ob bereits zu einem früheren Zeitpunkt Daten ausgelesen wurden damit ein Tageswechsel signalisiert werden kann. Hierzu wird der letzte Zeitstempel des letzten Datenabrufs, sofern vorhanden, mit dem aktuellen Datum verglichen. Ist das Ergebnis ungleich Null, liegt ein Tageswechsel vor und die Variablen werden entsprechend angepasst und mit dem Befehl \textsf{assign} im Base-Workspace aktualisiert.
\lstinputlisting[firstline=1, lastline=39]{programm/sendloop.m}
Im nächsten Schritt wird das Intervall \textit{fc\_int} für die auszulesenden Wetterdaten zusammengestellt. Hierbei muss unterschieden werden zwischen den stündlichen Werten der mittleren Lufttemperatur, dem begrenzten Prognosehorizont von Luftdruck und Solarleistung und den verbleibenden Daten. Gibt der Nutzer eine zu hohe Zahl für Luftdruck oder Solarleistung ein, so wird auf die möglichen Werte angepasst und eine Warnung ausgegeben.
\lstinputlisting[firstline=41, lastline=92]{programm/sendloop.m}
In diesem Abschnitt wird die MODBUS Nachricht erstellt und der Funktion \textsf{send\_and\_receive\_data} übergeben, die das Schreiben und Lesen auf der seriellen Schnittstelle übernimmt. Die Startadresse des Registers ergibt sich aus dem Prognosebereich, dem Prognosedetail und dem Anfangszeitpunkt zu dem die Werte ausgelesen werden sollen. Die Endadresse wird im gleichen Verfahren ermittelt (vgl.~\ref{sec:getregadd} auf S.~\pageref{sec:getregadd} im Anhang). Die Differenz aus den beiden Adressdaten ergibt die Registeranzahl (vgl.~\ref{sec:regnum} auf S.~\pageref{sec:regnum} im Anhang). Gemäß der MODBUS Spezifikation liegen nun fast alle Daten vor, die zur Kommunikation notwendig sind. Lediglich der Cyclic Redundancy Check fehlt noch. Dieser wird in der Funktion \textsf{gen\_msg} erstellt und der PDU zusammen mit der Slave-ID angeheftet (vgl. Kapitel~\ref{chp:CRC} auf S.~\pageref{chp:CRC}). Wie die momentane Verbindungsqualität \textit{con\_qual} zum Zeitpunkt der Anfrage ist, wird kurz darauf abgerufen. Ist in der Wetterbereichsdefinition auch die Temperatur mit aufgeführt, kann für einen später zu ermittelnden Korrekturfaktor die lokale Temperatur \textit{lokal\_temp} an der Wetterstation abgefragt werden. Alle für die weitere Verarbeitung erforderlichen Daten werden nun an die Funktion \textsf{send\_and\_receive\_data} übergeben. 
\lstinputlisting[firstline=93, lastline=113]{programm/sendloop.m}
Ist die for-Schleife durchlaufen und alle Daten liegen in den Datencontainern, wird der vollzogene Abruf in dem Container \textit{new\_data} mit entsprechendem Dateinamen abgespeichert. Der Dateiname setzt sich dabei aus dem Pfad zum Speicherort, dem Stadtnamen, der gewünschten Auflösung, dem aktuellen Datum und einem Datum in Unix Zeitformat zusammen. Ist das Speichern abgeschlossen, wird der Datencontainer geleert und neu initialisiert. Es folgt darauf das Update der noch verbleibenden Anzahl an Datenabrufen, welche in der Variable \textit{u\_c\_n} (update cycle number) hinterlegt sind. Zum Schluss wird der gesamte Base-Workspace für den Fall einer unbeabsichtigten Löschung zwischen den Abrufvorgängen gespeichert. 
\lstinputlisting[firstline=114, lastline=135]{programm/sendloop.m}
\section{Senden und Empfangen}
In dem Funktionsworkspace der Funktion \textsf{send\_and\_receive\_data} muss die serielle Schnittstelle zugänglich sein. Um die in der Funktion \textsf{send\_loop} generierte Nachricht über die Schnittstelle abschicken zu können, muss sie mit der Funktion \textsf{format\_modbus\_msg} auf ein geeignetes Format gebracht werden (vgl.~\ref{sec:formatmodbusmsg} auf S.~\pageref{sec:formatmodbusmsg} im Anhang). Dann erst kann die Nachricht mit dem Befehl \textit{fwrite} übermittelt werden. Es wird 1 Sekunde auf die Antwort gewartet. Das bestimmen der empfangenen Bytes und die Angabe beim Lesebefehl \textsf{fread} beschleunigt die Kommunikation. Jetzt liegt die Antwortnachricht des Servers in der Variablen \textit{rx\_data} vor. Die darin enthaltenen Werte wurden als unsigned integer 8 bit empfangen.
\lstinputlisting{programm/sendandreceivedata.m}
\section{Rx-Datenverarbeitung}\label{sec:rxdatenverarbeitung}
Hauptaufgabe der Rx-Datenverarbeitung ist es den empfangenen Funktionscode auszuwerten, die Daten zu isolieren und an eine weitere Funktion zur Bearbeitung zu übergeben. Der rx-Datenstring ist als Zeilenvektor aus einer Reihe von Dezimalzahlen folgendermaßen aufgebaut:
\begin{itemize}
\item an erster Stelle kommt die Slave-ID 
\item an zweiter Stelle folgt der Funktionscode 
\item an dritter Stelle steht die Anzahl der übertragenen Bytes
\item an den darauffolgenden Positionen befinden sich die Datenbytes
\item die beiden letzten Einträge beinhalten den CRC-Wert
\end{itemize}
Zu Beginn wird ein Flag für die while-Schleife initialisiert. Diese Schleife wird maximal dreimal durchlaufen. Die Kriterien, die zu einem Abbruch des Schleifendurchlaufs führen werden nachfolgend erklärt.
\lstinputlisting[firstline=1, lastline=9]{programm/rxdataprocessing.m}
Wurde keine Nachricht empfangen, definiert man eine Fehlermeldung und setzt das CRC-Check Flag \textit{crc\_check\_value} sowie den Funktionsoutput \textit{response\_data} auf Null. Diese Werte werden am Ende der Schleife geprüft und stellen das erste Kriterium für einen nochmaligen Durchlauf oder Abbruch dar. Sind Daten empfangen worden, wird der Funktionscode auf einen Fehlercode hin in der Funktion \textsf{fcode\_check} kontrolliert (vgl.~\ref{sec:fcodecheck} auf S.~\pageref{sec:fcodecheck} im Anhang). Ein Fehlercode wird registriert, wenn der Funktionscode nicht den Wert 1, 3 oder 6 besitzt. Um welchen Ausnahmefall es sich dann handelt, wird in der Switch-Abfrage geklärt. Liegt einer dieser Fehlercodes vor, wird die dazu passende Fehlernachricht erstellt. Ist der Funktionscode in Ordnung wird entschieden, wie mit den Datenbytes zu verfahren ist. Eine Switch-Abfrage führt zu den entsprechenden Arbeitsschritten. Für den Fall, dass der Funktionscode den Wert 1 oder 6 aufweist, ist die Bearbeitung recht einfach. Es müssen lediglich ein Datenbyte beim Code 1 und zwei Datenbytes beim Code 6 verarbeitet werden. Liegen dagegen ausgelesene Daten aus dem Holdingregister vor, muss die Funktion \textsf{data\_processing} aufgerufen werden. Egal welcher Fall auftritt, für jede Antwortnachricht des Servers wird ein CRC mit der Funktion \textsf{crc\_check} durchgeführt (vgl.~\ref{sec:crccheck} auf S.~\pageref{sec:crccheck} im Anhang). Ist die CRC Summe in Ordnung wird das CRC-Check Flag auf 1 gesetzt und keine Fehlermeldung zurückgegeben.
\lstinputlisting[firstline=11, lastline=55]{programm/rxdataprocessing.m}
Die Kriterien für die while-Schleife sind nun komplett. Ein erneuter Schleifendurchlauf wird dann angestoßen, wenn die CRC Summe fehlerhaft war, keine Daten gesendet wurden oder ein Fehlercode vorliegt und eine entsprechende Fehlermeldung generiert wurde.      
\lstinputlisting[firstline=57, lastline=71]{programm/rxdataprocessing.m}
\section{Datenverarbeitung}
Ein weiterer wichtiger Baustein dieses Programms ist die Datenverarbeitung, die mit der Funktion \textsf{data\_processing} gestartet wird. Neben den schon bekannten Parametern müssen hier noch die empfangen Datenbytes, im \textit{data\_string} hinterlegt, übergeben werden.
Da die Funktion auf Variablen aus dem Base-Workspace zurückgreift, muss man diese zuerst in den Funktionsworkspace von \textsf{data\_processing} laden. Danach liefert die Funktion \textsf{MESZ\_calc} ein Flag für die Mitteleuropäische Sommerzeit (vgl.~\ref{sec:meszcalc} auf S.~\pageref{sec:meszcalc} im Anhang). Im Anschluss werden die Listen für einen späteren Datenabgleich erstellt. 
\lstinputlisting[firstline=1, lastline=28]{programm/dataprocessing.m}
Erfolgt nur eine Abfrage der Kommunikationsparameter oder bestimmter Zustände der Wetterstation, muss nur ein Wert ausgewertet werden. Dies geschieht, wenn die If-Bedingung wahr ist. Da die Daten der seriellen Schnittstelle als unsigned int8 Werte empfangen wurden, werden negative Werte ab der Zahl 32769 dargestellt. Um sie zu erhalten muss der Wertebereich von 2 unsigned Bytes abgezogen werden.         
\lstinputlisting[firstline=30, lastline=40]{programm/dataprocessing.m}
Ist die If-Bedingung falsch, handelt es sich um Wetterdaten. Zunächst werden Variablen initiiert. Dabei ist \textit{i} eine Laufvariable, die die Position angibt zu dem ein Datumswechsel stattgefunden hat und der neue Satz Daten, die Prognosewerte überschreibt. \textit{n\_dat\_r} ist die Vektorposition in dem Datencontainer, der jeden einzelnen Datenabruf speichert. Deshalb ist sie immer auf 1 gesetzt. Da die Ausgangsdaten selbst in einer unterschiedlichen Auflösung gegeben sind, muss mit der Funktion \textsf{res\_factor} der entsprechende Faktor für die spätere Interpolation bestimmt werden (vgl.~\ref{sec:resfactor} auf S.~\pageref{sec:resfactor} im Anhang). Hat ein Abruf bereits zu einem früheren Zeitpunkt stattgefunden, so wird dieser Abruf-Zeitstempel der Variable \textit{t\_rec} zugewiesen. Er bestimmt sich aus dem letzten aufgezeichneten Wert und dessen Rekordstempel. Anschließend wird die Startvariable \textit{sdindex} der nachfolgenden for-Schleife für die zu bearbeitenden Prognosetage bestimmt. Dabei definiert die Position in der entsprechenden Liste diesen Wert. Der Endwert \textit{edindex} der Schleife wird in gleicher Weise bestimmt. 
\lstinputlisting[firstline=42, lastline=64]{programm/dataprocessing.m}
Lag noch kein vorheriger Datenabruf vor, so starten die Positionsvektoren des Datencontainers, der die Daten des Beobachtungszeitraums speichert, bei 1. Hier werden zwei Variablen \textit{w\_dat\_r} und \textit{w\_dat\_org} benötigt. Während die Erste später mit der interpolierten zeitlichen Auflösung voranschreitet, behält die Zweite die ursprüngliche Schrittweite. Liegt nach dem erstmaligen Funktionsaufruf kein Datumswechsel vor aber ein zweites Update steht am selben Tag an, dann müssen diese Variablen noch immer den Wert eins aufweisen. Hierdurch werden die Daten durch \enquote{Intraday-Updates} überschrieben. Die Bedingung für die konstante Position ergibt sich aus der Differenz des letzten Rekordstempel mit dem aktuellen Datum. Hierfür wird der Unix Zeitstempel in das normale Datumsformat \enquote{dd-mmm-yyyy} mit der Funktion \textsf{utc2date} und dem Befehl \textsf{datestr} konvertiert (vgl.~\ref{sec:utc2date} auf S.~\pageref{sec:utc2date} im Anhang). Tritt ein Datumswechsel auf, bestimmt die while-Schleife diese Position im Datensatz. Dazu wird die in der Variable \textit{unix\_t\_strt} gespeicherte Zeitreihe durchlaufen bis das Datum der alten Zeitreihe dem dem Startdatum der neuen Datenreihe entspricht. Der Wert wird der Vektorposition übergeben. Abhängig ob es sich um Daten handelt die interpoliert werden, bekommt auch die Vektorposition für die originalen Daten einen Wert zugewiesen. Er errechnet sich entsprechend der Auflösung der Daten für die mittlere Lufttemperatur (24 Werte pro Tag) multipliziert mit der Zahl der bis dato vollzogenen Tageswechseln plus eins.   
\lstinputlisting[firstline=66, lastline=108]{programm/dataprocessing.m}
Handelt es sich um einen längeren Datenstring, so muss dieser durchlaufen werden. Es erfolgt eine Initialisierung dieser Variablen. Danach beginnt die Schleife für den Tagesdurchlauf. Zu Beginn wird je nach Schleifenpostition der Anfangs- und Endwert der Schleife für die Tagessegmente bestimmt. Der hier verwendete Aufbau scheint ein wenig kompliziert zu sein und stammt aus einer Version in der es möglich war völlig willkürliche Intervalle zu bestimmen und nicht nur tagesweise den Abruf zu durchlaufen. Sind Start- und Endwerte für die Tagessegment-Schleife bestimmt, wird im letzten Schritt das Datum der Schleifenposition ermittelt und in der Variablen \textit{date\_part} gespeichert. Diese wird später für die Berechnung der Unix Zeitstempel benötigt.        
\lstinputlisting[firstline=110, lastline=176]{programm/dataprocessing.m}
Es beginnt nun der Schleifendurchlauf für die Tagessegmente und damit die Auswertung des Datenstrings. Jeder Wert für ein Tagessegment ist dabei aus einem High- und Low-Byte in dezimalem Format aufgebaut und muss deshalb zuerst in ein hex-Format und nach Zusammensetzung wieder in ein Dezimalformat konvertiert werden. Für die Unix-Zeitstempelberechnung wird ein Datumsvektor benötigt, der in der Funktion \textsf{tvector} für die Wetterdaten erstellt wird (vgl.~\ref{sec:tvector} auf S.~\pageref{sec:tvector} im Anhang). Der Vektor gibt jeweils den Beginn des Intervalls an, für den der bearbeitete Wert gültig ist. Liegt ein Wert von 10000 an, wird eine Warnmeldung an den Nutzer ausgegeben und der komplette Prognosebereich nicht weiter bearbeitet. Die Zeitschritte, die die Zeitreihe bestimmen werden in der nachfolgenden If-Bedingung bestimmt. Dabei ist \textit{timestep} der normale Zeitschritt ohne Interpolation. Für die mittlere Lufttemperatur beträgt sie eine Stunde für die anderen Bereiche 6 Stunden. Der Subtrahend 1 entstammt der Intervalleingrenzung, die auf 00:00:00 Uhr bis 00:59:59 festgelegt wurde. Bei einer Interpolation müssen die Zeitschritte angepasst werden. Bei einer Auflösung von 5 Min. muss z.B. das einstündige Intervall um 55 Min. gekürzt werden.
\lstinputlisting[firstline=178, lastline=224]{programm/dataprocessing.m} 
In diesem Abschnitt werden die Werte dem Datencontainer zugewiesen. Es sind dabei folgende Variablen zu belegen:
\begin{itemize}
\item \textit{unix\_t\_strt} enthält den Startzeitpunkt in Unix Zeitformat des Intervalls für den der interpolierte Wert später vorliegt
\item \textit{unix\_t\_end} enthält den Endzeitpunkt in Unix Zeitformat des Intervalls für den der interpolierte Wert später vorliegt
\item \textit{unix\_t\_mean} enthält den Mittelwert in Unix Zeitformat des Intervalls für den der interpolierte Wert später vorliegt
\item \textit{interval\_t\_clr} enthält Start- und Endzeitpunkt des Intervalls in normalem Zeitformat
\item \textit{int\_val} enthält den interpolierten Wetterdatenwert
\item \textit{org\_val} enthält den nicht interpolierten ausgelesenen Wetterdatenwert
\item \textit{con\_qual} enthält die Verbindungsqualitätsdaten
\item \textit{loc\_temp} nur für die Daten im Temperaturbereich   
\end{itemize}
Die Transformation in das Unixzeitformat übernimmt die Funktion \textsf{date2utc} (vgl.~\ref{sec:date2utc} auf S.~\pageref{sec:date2utc} im Anhang). Außerdem müssen die Werte der Niederschlagsmenge und der Sonnenscheindauer mit einem eigenen Faktor beaufschlagt werden um die Einheiten l/m² und h zu bekommen. Dies erledigt die Funktion \textsf{data\_mult} (vgl.~\ref{sec:datamult} auf S.~\pageref{sec:datamult} im Anhang).
Am Schluss eines Schleifendurchlaufs müssen die Vektorpositionen des Datenstrings und der Zeitreihen angepasst bzw. inkrementiert werden. 
\lstinputlisting[firstline=226, lastline=287]{programm/dataprocessing.m}
\subsection{Interpolation}
Für den Fall, dass eine Auflösung von 6 Stunden gewünscht ist, wird nicht interpoliert und die Werte können so im Datencontainer in den Base-Workspace abgelegt werden.   
\lstinputlisting[firstline=301, lastline=306]{programm/dataprocessing.m} 
Wird eine andere Auflösung als die Originale gefordert, so können die Werte (Windrichtung, Markantes Wetter, Signifikantes Wetter und Niederschlagswahrscheinlichkeit), die nicht interpoliert werden gleich im Base-Workspace gespeichert werden. 
\lstinputlisting[firstline=307, lastline=316]{programm/dataprocessing.m} 
Für die die Werte der Solarleistung müssen der Sonnenauf- und Sonnenuntergangszeitpunkt bestimmt werden. Tut man dies nicht, so wird später eine Sonnenscheindauer bzw. Globalstrahlung von 0.00 Uhr bis 23.59 Uhr interpoliert. Die Funktion \textsf{diurnal\_var} bestimmt diese Werte mit Hilfe der Längen- und Breitengradangabe der Wetterregion sowie dem entsprechenden Datum. Der Algorithmus zur Berechnung dieser Daten wurde aus dem Buch \enquote{Photovoltaik Engeneering} entnommen (vgl.~\ref{sec:diurnalvar} auf S.~\pageref{sec:diurnalvar} im Anhang). Die Messwerte der Wetterstation werden dann auf vier gleiche Zeitintervalle von Sonnenauf- bis Sonnenuntergang aufgeteilt. 
\lstinputlisting[firstline=317, lastline=344]{programm/dataprocessing.m}
\begin{figure}[!h]
\centering
\includegraphics[scale=0.7]{programm/intneuber}
\caption{Neuberechnung Intervallanzahl und -startwerte}
\label{fig:intneuber}
\end{figure}
Wenn noch kein Datenabruf vorher stattgefunden hat, wird das Ende des Datensatzes durch die Vektorlänge des mittleren Zeitreihenintervalls \textit{unix\_t\_mean} multipliziert mit dem Faktor für die Auflösung festgelegt. Fanden dagegen schon zuvor Datenabfragen statt, dann berechnet sich das Ende durch Addition der neuen interpolierten Werte auf die Position des Datumwechsels. In den darauffolgenden Schritten werden die Endzeitpunkte des Gültigkeitsintervalls neu berechnet, indem die alten Intervallgrenzen um die Korrekturfaktoren \textit{timestep\_corr} verschoben werden. Auch die Intervallmitte \textit{unix\_t\_mean} und die Angabe der Intervallgrenzen im normalen Zeitformat werden neu berechnet. Die \textbf{Abbildung \ref{fig:intneuber}} soll den Vorgang etwas verdeutlichen.    
\lstinputlisting[firstline=346, lastline=391]{programm/dataprocessing.m}
Sind die Startpositionen bekannt, können jetzt die kompletten Zeitreihen z.B. mit 5 Min. Schritten erstellt werden.       
\lstinputlisting[firstline=393, lastline=452]{programm/dataprocessing.m}
\begin{figure}[!h]
\centering
\includegraphics[scale=0.7]{programm/slm}
\caption{Parameterbestimmung für die slm-Funktion}
\label{fig:slm}
\end{figure}
In diesem Teil des Programms erfolgt nun die Interpolation der Ausgangswerte. Dabei werden alle für die Interpolation vorgesehenen Bereiche mit dem \enquote{shape language modeling} \cite{SLM} interpoliert. Es besteht die Möglichkeit in dieser Funktion die Anzahl der Spline-Knoten festzulegen. Für die mittlere Lufttemperatur wurde die Knotenzahl von 96 möglichen (96 Werte liegen vor) auf 48 halbiert. Hierdurch werden zwar nicht alle existierenden Werte korrekt durchlaufen, dafür ist die Kurve im Vergleich zu 96 Knoten wesentlich glatter im Verlauf (siehe \textbf{Abbildung \ref{fig:intvergleich}}). Für einen erstmaligen Aufruf wird die linke und rechte Steigung des Graphen mit den Einstellungsparametern \textit{leftslope} und \textit{rightslope} auf 0 festgelegt. Liegen indes schon Daten vor, so wird die linksseitige Steigung der letzten beiden vorangegangenen Graphenpunkte bestimmt 
\begin{equation}
m = \frac{y_{i-1}-y_{i-2}}{x_{i-1}-x_{i-2}}
\end{equation} 
und als Bedingung der \textsf{slm} Funktion für den linkseitigen Steigungswert vorgegeben (vgl. \textbf{Abbildung \ref{fig:slm}}). Zusätzlich muss der neue Graph mit dem letzten Graphenwert der vorigen Daten beginnen. So soll ein fließender Übergang der Graphen sichergestellt werden. 
\begin{figure}[!h]
\centering
\includegraphics[width=11cm,height=7cm]{programm/slmvergleich}
\caption{Vergleich der Interpolationsfunktionen}
\label{fig:intvergleich}
\end{figure} 
Die Funktion \textsf{neg\_val\_corr} hat zur Aufgabe, negative Werte für Wetterbereiche, die keine negativen Werte aufweisen können auf Null zu setzten (vgl.~\ref{sec:datamult} auf S.~\pageref{sec:datamult} im Anhang). Hierzu zählen unter anderem die Solarstrahlung und Sonnenscheindauer. Für diese müssen zusätzlich durch die Interpolation außerhalb des Sonnenauf- und -untergangs entstandenen positive Werte ebenfalls auf Null gesetzt werden.
\lstinputlisting[firstline=455, lastline=508]{programm/dataprocessing.m}
Für die Daten, die nicht in einer fortlaufenden Zeitreihe gespeichert werden, sind die linken und rechten Steigungen auf 0 gesetzt.   
\lstinputlisting[firstline=510, lastline=526]{programm/dataprocessing.m}
Möchte man doch alle originalen Messwerte der Wetterstation im Graphen berücksichtigt haben, so kann hier die normale MATLAB-Funktion \textsf{spline} verwendet werden. Hierbei wird immer der letzte Wert des vorigen Abrufs mit in die Berechnung einbezogen. Dazu kommentiert man den Bereich mit der slm-Funktion und unkommentiert diesen Bereich. Auch hier wird die Funktion \textsf{neg\_val\_corr} angewandt. Zum Abschluss werden die beiden Datencontainer dem Base-Workspace zugewiesen. 
\lstinputlisting[firstline=528, lastline=572]{programm/dataprocessing.m}   